#version 450
#extension GL_ARB_separate_shader_objects : enable

const float c_gridDepthValues[5] = {1.0, 5.0, 20.0, 50.0, 100.0}; // This matches te NCP and FCP in ClusteredApp.cpp
const int c_workgroupSize = 32;
layout (local_size_x = c_workgroupSize, local_size_y = c_workgroupSize, local_size_z = 1) in;

layout(binding = 0) uniform TransformationMatrices
{
    mat4 world;
    mat4 view;
    mat4 proj;
	mat4 inverseProj;
} matrices;

layout(std140, binding = 1) uniform sceneInfo
{
	float ncp;
	float fcp;
	uint lightCount;
	uint maxLightsPerTile;
} scene;

struct Light
{
	vec4 position;
	vec4 color;
};

layout(std140, binding = 2) buffer lightBuffer 
{	
	Light lights[];
};

layout(std430, binding = 3) buffer tileBuffer 
{
	uint lightIndex[];
};

layout(std430, binding = 4) buffer numLightsPerTileBuffer 
{
	uint numLights[];
};

vec3 getPlane(vec3 p0, vec3 p1, vec3 p2 )
{
	vec3 v0 = p1 - p0;
    vec3 v2 = p2 - p0;
    return normalize(cross(v0, v2));
}

bool isSphereInFrontOfPlane(vec4 sphere, vec3 plane)
{
    return (-dot(plane, sphere.xyz)) < sphere.w;
}

bool isSphereInFrontOfFCP(vec4 sphere, uint depth)
{
	return (-sphere.z - sphere.w) < c_gridDepthValues[depth + 1];
}

bool isSphereBehindNCP(vec4 sphere, uint depth)
{
	return (-sphere.z + sphere.w) > c_gridDepthValues[depth];
}

void main() 
{
	vec2 tileId = gl_LocalInvocationID.xy;
	float step = 2.0 / c_workgroupSize;
	float xPos = -1.0 + tileId.x * step;
	float yPos = 1.0 - tileId.y * step;
	uint depth = gl_WorkGroupID.z;
	float ncp = c_gridDepthValues[depth];
	
	vec4 clipSpace[4];
	clipSpace[0] = vec4(xPos, yPos, 1.0, 1.0); // top left
	clipSpace[1] = vec4(xPos + step, yPos, 1.0, 1.0); // top right
	clipSpace[2] = vec4(xPos, yPos - step, 1.0, 1.0); // bottom left
	clipSpace[3] = vec4(xPos + step, yPos - step, 1.0, 1.0); // bottom right

	vec4 viewSpace[4];
	for (int i = 0; i < 4; ++i)
	{
		viewSpace[i] = matrices.inverseProj * clipSpace[i];
	}

	vec3 planes[4];
	vec3 origo = vec3(0.0);
	planes[0] = getPlane(origo, viewSpace[2].xyz, viewSpace[0].xyz); // left
	planes[1] = getPlane(origo, viewSpace[1].xyz, viewSpace[3].xyz); // right
	planes[2] = getPlane(origo, viewSpace[0].xyz, viewSpace[1].xyz); // top
	planes[3] = getPlane(origo, viewSpace[3].xyz, viewSpace[2].xyz); // bottom

	int insideTileCounter = 0;
	uint offset = (depth * gl_WorkGroupSize.x * gl_WorkGroupSize.y * scene.maxLightsPerTile) 
	+ (gl_LocalInvocationID.y * gl_WorkGroupSize.x * scene.maxLightsPerTile) 
	+ (gl_LocalInvocationID.x * scene.maxLightsPerTile);
	for (int i = 0; i < scene.lightCount; ++i)
	{
		vec4 light = lights[i].position;
		vec4 lightView = matrices.view * vec4(light.xyz, 1.0);
		lightView.w = light.w;
		bool insideTile = 
			isSphereInFrontOfFCP(lightView, depth) &&
			isSphereBehindNCP(lightView, depth) &&
			isSphereInFrontOfPlane(lightView, planes[0]) && 
			isSphereInFrontOfPlane(lightView, planes[1]) && 
			isSphereInFrontOfPlane(lightView, planes[2]) && 
			isSphereInFrontOfPlane(lightView, planes[3]);

		if (insideTile && insideTileCounter < scene.maxLightsPerTile)
		{
			lightIndex[offset + insideTileCounter] = i; 
			++insideTileCounter;
		}
	}

	uint numLightsIndex = (depth * gl_WorkGroupSize.x * gl_WorkGroupSize.y) 
	+ (gl_LocalInvocationID.y * gl_WorkGroupSize.x)
	+ gl_LocalInvocationID.x;
	numLights[numLightsIndex] = insideTileCounter;
}