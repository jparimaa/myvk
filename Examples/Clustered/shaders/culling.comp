#version 450
#extension GL_ARB_separate_shader_objects : enable

const float c_gridDepthValues[5] = {1.0, 5.0, 20.0, 50.0, 100.0}; // This matches te NCP and FCP in ClusteredApp.cpp
const int c_workgroupSize = 32;
layout (local_size_x = c_workgroupSize, local_size_y = c_workgroupSize, local_size_z = 1) in;

layout(binding = 0) uniform TransformationMatrices
{
    mat4 world;
    mat4 view;
    mat4 proj;
	 mat4 inverseProj;
}
matrices;

struct Light
{
	vec4 position;
	vec4 color;
};

layout(std140, binding = 1) buffer lightBuffer 
{
   Light lights[];
};

layout(std140, binding = 2) buffer lightIndexBuffer 
{
   uint lightIndex[];
};

struct Tile
{
	uint offset;
	uint count;
};

layout(std140, binding = 3) buffer tileBuffer 
{
   Tile tiles[];
};

vec3 getPlane(vec3 p0, vec3 p1, vec3 p2 )
{
    vec3 v0 = p1 - p0;
    vec3 v2 = p2 - p0;
    return normalize(cross(v0, v2));
}

void main() 
{
	vec2 tileId = gl_LocalInvocationID.xy;
	float step = 2.0 / c_workgroupSize;
	float xPos = -1.0 + tileId.x * step;
	float yPos = 1.0 - tileId.y * step;
	uint depth = gl_WorkGroupID.z;
	float ncp = c_gridDepthValues[depth];
	
   vec4 clipSpace[4];
	clipSpace[0] = vec4(xPos, yPos, ncp, 1.0); // top left
	clipSpace[1] = vec4(xPos + step, yPos, ncp, 1.0); // top right
	clipSpace[2] = vec4(xPos, yPos - step, ncp, 1.0); // bottom left
	clipSpace[3] = vec4(xPos + step, yPos - step, ncp, 1.0); // bottom right

	vec4 viewSpace[4];
	for (int i = 0; i < 4; ++i)
	{
		viewSpace[i] = matrices.inverseProj * clipSpace[i];
	}

	vec3 planes[4];
	vec3 origo = vec3(0.0);
	planes[0] = getPlane(origo, clipSpace[2].xyz, clipSpace[0].xyz); // left
	planes[1] = getPlane(origo, clipSpace[1].xyz, clipSpace[3].xyz); // right
	planes[2] = getPlane(origo, clipSpace[0].xyz, clipSpace[1].xyz); // top
	planes[3] = getPlane(origo, clipSpace[3].xyz, clipSpace[2].xyz); // bottom

	int index = int(gl_GlobalInvocationID);
	lights[index].color.w = 9.0;
}